package HashingPackage;

import java.util.Iterator;
import java.util.NoSuchElementException;

import DictionaryPackage.*;

/**
 * A class that implements the ADT dictionary by using hashing and linear
 * probing to resolve collisions. The dictionary is unsorted and has distinct
 * search keys. Notes: Uses probe for add, remove, and getValue. Uses linear
 * probing, but includes code for quadratic probing. Has a display method for
 * illustration and testing.
 * 
 * @author Babanjot Singh
 */
public class HashedDictionary<K extends Comparable<? super K>, V> implements DictionaryInterface<K, V> {
	// The dictionary:
	private int numberOfEntries;

	// capacity must be prime, which checkCapacity will automatically set
	// if this is set too low with quadratic probe, search time increases.
	private static final int DEFAULT_CAPACITY = 5;
	private static final int MAX_CAPACITY = 1000000;

	// The hash table:
	private Entry<K, V>[] hashTable;

	private static final int MAX_SIZE = 2 * MAX_CAPACITY; // Max size of hash table
	private static final double MAX_LOAD_FACTOR = 0.5; // Fraction of hash table that can be filled

	private final Entry<K, V> AVAILABLE = new Entry<>(null, null); // Occupies locations in the hash table in the
																	// available state (locations whose entries were
																	// removed)

	public HashedDictionary() {
		this(DEFAULT_CAPACITY);
	}

	public HashedDictionary(int initialCapacity) {
		initialCapacity = checkCapacity(initialCapacity);
		numberOfEntries = 0;

		int tableSize = getNextPrime(initialCapacity);
		checkSize(tableSize);

		@SuppressWarnings("unchecked")
		Entry<K, V>[] temp = (Entry<K, V>[]) new Entry[tableSize];
		hashTable = temp;

	}

	@Override
	public V add(K key, V value) {
		if ((key == null) || (value == null))
			return null;
		V oldValue;
		int index = getHashIndex(key);
		assert (index >= 0) && (index < hashTable.length);
		if (!hasAnEntry(index)) {
			hashTable[index] = new Entry<>(key, value);
			numberOfEntries++;
			oldValue = null;
		} else {
			oldValue = hashTable[index].getValue();
			hashTable[index].setValue(value);
		}

		if (isHashTableTooFull())
			enlargeHashTable();
		return oldValue;
	}

	@Override
	public V remove(K key) {
		V removedValue = null;
		int index = getHashIndex(key);

		if (hasAnEntry(index)) {
			removedValue = hashTable[index].getValue();
			hashTable[index] = AVAILABLE;
			numberOfEntries--;
		}

		return removedValue;
	}

	@Override
	public V getValue(K key) {
		V result = null;
		int index = getHashIndex(key);
		if (hasAnEntry(index))
			result = hashTable[index].getValue();
		return result;
	}

	@Override
	public boolean contains(K key) {
		return hasAnEntry(getHashIndex(key));
	}

	@Override
	public boolean isEmpty() {
		return numberOfEntries <= 0;
	}

	@Override
	public int size() {
		return numberOfEntries;
	}

	@Override
	public void clear() {
		@SuppressWarnings("unchecked")
		Entry<K, V>[] temp = (Entry<K, V>[]) new Entry[DEFAULT_CAPACITY];
		hashTable = temp;
		numberOfEntries = 0;
	}

	/**
	 * Checks to see if the index into the hash table is occupied
	 * 
	 * @param index
	 * @return true if there is an entry
	 */
	public boolean hasAnEntry(int index) {
		return (hashTable[index] != null) && (hashTable[index] != AVAILABLE);
	}

	public Iterator<K> getKeyIterator() {
		return new KeyIterator();
	}

	public Iterator<V> getValueIterator() {
		return new ValueIterator();
	}

	/**
	 * Get the next available hash index for the key
	 * 
	 * @param key
	 * @return
	 */
	private int getHashIndex(K key) {
		int hashIndex = setHashIndex(key.hashCode());
		hashIndex = linearProbe(hashIndex, key);
		return hashIndex;
	}

	/**
	 * Take a hashcode and make sure it fits in the hash table. Wraparound if
	 * necessary using mod tablelength. If the resulting index is < 0, add the table
	 * length to it.
	 * 
	 * @param index
	 * @return index % tablelength
	 */
	private int setHashIndex(int index) {
		index = index % hashTable.length;
		if (index < 0)
			index = index + hashTable.length;
		return index;
	}

	/**
	 * Probe the array for key or failing that, the next unused location
	 * 
	 * The index should be generated by a hash code % dictionarySize
	 * 
	 * Use linear probing
	 * 
	 * @param index
	 * @param key
	 * @return
	 */
	private int linearProbe(int index, K key) {
		boolean found = false;

		int availableIndex = -1;

		while (!found && (hashTable[index] != null)) {

			if (hasAnEntry(index)) {
				if (key.equals(hashTable[index].getKey()))
					found = true;
			} else {
				if (availableIndex == -1)
					availableIndex = index;
			}
			if (!found)
				index = setHashIndex(index + 1);
		}
		if (found || (availableIndex == -1))
			return index;
		else
			return availableIndex;
	}

	/**
	 * Increases the size of the hash table to a prime >= twice its old size. In
	 * doing so, this method must rehash the table entries.
	 */
	private void enlargeHashTable() {
		Entry<K, V>[] oldTable = hashTable;
		int oldSize = hashTable.length;
		int newSize = getNextPrime(oldSize + oldSize);
		checkSize(newSize);

		@SuppressWarnings("unchecked")
		Entry<K, V>[] tempTable = (Entry<K, V>[]) new Entry[newSize];

		hashTable = tempTable;
		numberOfEntries = 0;

		for (int index = 0; index < oldSize; index++) {
			if ((oldTable[index] != null) && (oldTable[index] != AVAILABLE))
				add(oldTable[index].getKey(), oldTable[index].getValue());
		}
	}

	/**
	 * Returns true if lambda > MAX_LOAD_FACTOR for hash table;
	 * 
	 * @return
	 */
	private boolean isHashTableTooFull() {
		return numberOfEntries > MAX_LOAD_FACTOR * hashTable.length;
	}

	/**
	 * Returns a prime integer that is >= the given integer.
	 * 
	 * Note this should be < MAX_SIZE but is not checked.
	 * 
	 * @param anInteger
	 * @return the next prime number in the series of integers
	 */
	private int getNextPrime(int anInteger) {
		// if even, add 1 to make odd
		if (anInteger % 2 == 0) {
			anInteger++;
		}

		// test odd integers
		while (!isPrime(anInteger)) {
			anInteger = anInteger + 2;
		}

		return anInteger;
	}

	/**
	 * From Sedgewick Copyright © 2000–2017, Robert Sedgewick and Kevin Wayne.
	 * 
	 * Checks to see if a number is prime.
	 * 
	 * Simpler code
	 * 
	 * @param n
	 * @return true if a prime number
	 */
	private boolean isPrime(int n) {

		boolean isPrime = true;

		if (n < 2)
			isPrime = false;

		for (long factor = 2; factor * factor <= n; factor++) {

			if (n % factor == 0) {
				isPrime = false;
				break;
			}
		}

		return (isPrime);
	}

	/**
	 * Ensures that the client requests a capacity that is not too small or too
	 * large.
	 * 
	 * @param capacity
	 * @return
	 */
	private int checkCapacity(int capacity) {
		if (capacity < DEFAULT_CAPACITY)
			capacity = DEFAULT_CAPACITY;
		else if (capacity > MAX_CAPACITY)
			throw new IllegalStateException(
					"Attempt to create a dictionary " + "whose capacity is larger than " + MAX_CAPACITY);
		return capacity;
	}

	/**
	 * Throws an exception if the hash table becomes too large.
	 * 
	 * @param size
	 */
	private void checkSize(int size) {
		if (size > MAX_SIZE)
			throw new IllegalStateException("Dictionary has become too large.");
	}

	private class KeyIterator implements Iterator<K> {
		private int currentIndex; // Current position in hash table
		private int numberLeft; // Number of entries left in iteration

		private KeyIterator() {
			currentIndex = 0;
			numberLeft = numberOfEntries;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}

		@Override
		public boolean hasNext() {
			return numberLeft > 0;
		}

		@Override
		public K next() {
			K result = null;
			if (hasNext()) {
				while (!hasAnEntry(currentIndex)) {
					currentIndex++;
				}
				result = hashTable[currentIndex].getKey();
				numberLeft--;
				currentIndex++;
			} else
				throw new NoSuchElementException();
			return result;
		}
	}

	private class ValueIterator implements Iterator<V> {
		private int currentIndex;
		private int numberLeft;

		private ValueIterator() {
			currentIndex = 0;
			numberLeft = numberOfEntries;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}

		@Override
		public boolean hasNext() {
			return numberLeft > 0;
		}

		@Override
		public V next() {
			V result = null;
			if (hasNext()) {

				while (!hasAnEntry(currentIndex)) {
					currentIndex++;
				}
				result = hashTable[currentIndex].getValue();
				numberLeft--;
				currentIndex++;
			} else
				throw new NoSuchElementException();
			return result;
		}
	}
}
